Построение моделей систем на базе эквациональной характеристики формул LTL



Верификация работы программных и технических систем является неотъемлемой частью их жизненного цикла. Существует целый ряд инструментов и средств верификации, которые являются более удобными и эффективными при тех или иных условиях, на тех или иных этапах проектирования и сопровождения. Однако за последние два десятилетия лучше всего себя зарекомендовали инструменты формальной верификации, работа которых может быть автоматизирована, а корректность функционирования – доказана формально. Наиболее активно используемым инструментом на сегодняшний день является метод формальной верификации на моделях, или Model Checking .

Технология процесса верификации программных и технических систем методом проверки на моделях подразумевает создание моделей систем, свойства которых требуется проверить. Так, например, модель системы может быть задана с помощью различных структур данных, в частности таких, как структура Крипке, язык асинхронных процессов Promela, в виде конечного автомата и т.д. Однако независимо от представления модели системы и верифицируемых свойств, заданных на базе логики линейного времени (LTL) , необходим, как правило, процесс их преобразования к автоматам Бюхи. При этом алгоритмы преобразования формул LTL в автоматы Бюхи являются нетривиальными, а принципы их функционирования непонятны на интуитивном уровне.

В данной статье рассматривается новая нотация RLTL (recursive linear temporal logic) для представления формул LTL в виде системы рекурсивных уравнений с целью расширения ее описательной мощности . Кроме того, RLTL может быть использована и для задания моделей верифицируемых систем, что предоставляет следующие важные преимущества:  задание как модели самой системы, так и проверяемых относительно нее свойств на базе единой структуры данных;  возможность быстрого и интуитивно понятного преобразования RLTL-структур в автоматы Бюхи для их последующей верификации;  возможность выполнения верификации без преобразования к автомату Бюхи;  ускорение процесса верификации, что крайне важно при верификации больших распределенных программных систем.

RLTL-нотация 

Рассмотрим рекурсивные представления основных базовых операторов LTL (табл. 1).

Символом  обозначен оператор продолжения (конкатенация выражений), что позволяет использовать оператор X в неявном виде, а также упростить его восприятие, в частности, запись  будет пониматься как « следует за ». Под символом , далее именуемым предикатом неопределенности, будем понимать некоторое неопределенное подмножество символов входного алфавита. Под отрицанием предиката неопределенности будем понимать некоторое другое неопределенное подмножество символов алфавита, а под отрицанием отрицания – некоторое третье неопределенное подмножество. Таким образом, отрицание предиката неопределенности является неполным, а каждое последующее отрицание дает неопределенное подмножество символов. Каждое из этих подмножеств ввиду своей неопределенности также может быть обозначено через .

В таблице 1 представлены почти все операторы, используемые в LTL, кроме оператора, у которого отсутствует рекурсивная форма. Таким образом, поскольку все основные операторы LTL могут быть представлены в рекурсивной форме, авторы полагают, что приведение их к некоторому унифицированному виду, который, следуя , будем именовать эквациональной характеристикой, позволит существенно расширить описательную способность LTL и упростит процесс верификации ее формул.

Сочетания операторов LTL также могут быть выведены с помощью аксиом в рамках эквациональной характеристики. В таблице 2 приведены некоторые сочетания операторов LTL.

Построение RLTL-моделей 

Структуры на базе RLTL-нотации могут быть интерпретированы в качестве недетерминированного конечного автомата, который на вход получает бесконечные цепочки и моделирует поведение реагирующих систем. Так, рассмотрим формальное определение автомата Бюхи. Автомат Бюхи – это пятерка, где конечное множество символов (алфавит);  множество состояний; – множество начальных состояний (содержащее только один элемент для детерминированного случая); отношение переходов (для детерминированного автомата множество допускающих (финальных) состояний.

Нетрудно убедиться, что любая структура на базе RLTL-нотации может быть интерпретирована в качестве автомата Бюхи в соответствии с данным определением. В качестве алфавита в RLTL также выступает некоторое множество символов. В качестве состояний выступает множество метапеременных, задающих уравнения системы. По умолчанию в качестве начального состояния выступает метапеременная первого уравнения системы, однако, если существует несколько начальных состояний, их можно задать в виде элементов соответствующего множества. Функция переходов для RLTL остается аналогичной автоматам Бюхи, где в роли переходов выступает оператор продолжения , за которым следует метапеременная, обозначающая состояние, в которое осуществляется переход. Что касается множества допустимых или финальных состояний, то в RLTL не существует аналога, поэтому необходимо явное задание множества соответствующих метапеременных.

Для задания с помощью RLTL-нотации моделей систем достаточно использовать лишь тройку значений, поскольку каждое состояние модели системы является допустимым, а любое множество начальных состояний из более чем одного элемента может быть заменено единственным начальным состоянием, из которого существуют переходы по любому из символов алфавита в каждое из этих состояний. В качестве примера зададим в терминах RLTL простую модель работы светофора на основе ее устного описания: «Горит зеленый сигнал, затем загорается желтый, а после желтого – красный. После красного сигнала снова загорается желтый, за ним зеленый. В такой последовательности сигналы продолжают чередоваться дальше». Опишем модель работы светофора следующей тройкой значений зеленый сигнал светофора желтый сигнал; красный сигнал. В RLTL-нотации модель будет иметь следующий вид.

Использование пятерки значений  требуется лишь в тех случаях, когда необходимо превратить данные на базе RLTL в автомат Бюхи. Так, пусть дана формула LTL «всегда в будущем будет наступать». В терминах RLTL нотации она будет выглядеть следующим образом.

В данном случае система задана тройкой значений. Для превращения данной формулы в автомат Бюхи достаточно указать множество начальных и множество допустимых состояний. Аналогично может быть задана и модель любой системы на базе RLTL.

Таким образом, любая RLTL-структура, использующая тройку значений, может быть превращена в автомат Бюхи за счет задания множеств начальных и допустимых состояний. Возможность простого и интуитивно понятного превращения формул RLTL в автоматы Бюхи и наоборот, как и представленные выше примеры, подтверждает возможность задания моделей верифицируемых систем сразу на базе RLTL. Сам процесс задания моделей систем может быть выполнен двумя способами:  построение модели системы на базе структуры Крипке с ее последующим преобразованием в RLTL; поскольку структуры Крипке могут быть быстро преобразованы в автоматы Бюхи , их преобразование в RLTL-формулы также выполняется относительно просто;  непосредственное построение моделей систем сразу на базе RLTL-нотации, что является более приемлемым, поскольку дальнейшие преобразования для их верификации не требуются.

Абстракция и унификация RLTL-моделей 

Для повышения быстродействия процесса верификации больших распределенных систем существует ряд специальных инструментов, средств и алгоритмов:  редукция частичных порядков ;  абстракция данных ;  хэширование битовых состояний (вместо полных состояний хранится лишь их хэш, что снижает требования к объему памяти, но уменьшает полноту системы) ;  ускорение проверки «корректности в слабом смысле», или Weak Fairness .

Использование данных средств позволяет снизить проблему комбинаторного взрыва, то есть быстрого роста числа состояний.

Для упрощения моделей систем введем операции абстракции и унификации. Операция абстракции позволяет осуществлять сокращение числа свойств моделей систем, а операция унификации – объединение однотипных элементов. Операцию абстракции обозначим как , где множество заменяемых символов; заменяющий символ (тот символ, на который заменяются элементы из множества); атомарный предикат (символ алфавита); формула. Аксиомы, описывающие свойства данной операции, представлены далее: Операция унификации базируется на четырех основных правилах: Их использование позволяет сократить число состояний системы, а также число ее переходов, где множество унифицируемых индексов.

В качестве примера возьмем некоторый вариант модели алгоритма «читатели-писатели» для трех «писателей» и двух «читателей». Модель соответствующей системы представлена в виде структуры Крипке на рисунке.

Сформулируем модель данной системы в терминах RLTL-нотации. Каждому состоянию модели Крипке будет сопоставлена своя метапеременная, определяющая соответствующее уравнение системы. В качестве алфавита будет выступать. Переходы, ведущие из конкретного состояния, будут помечены символом этого состояния. Поскольку первое состояние системы не помечено ни одним символом, в RLTL все переходы из данного состояния будут помечены символом неопределенности, или .

Важно учитывать, относительно чего планируется производить упрощение системы. Так, в данном случае пусть проверка системы будет выполняться относительно следующего условия, заданного в терминах LTL «Всегда в будущем процесс записи для любого из «писателей» будет обязательно завершен». Как видно из формулы, в процессе верификации не будет анализироваться ни один из «читателей», так как в формуле не участвуют предикаты. В связи с этим можно выполнить абстракцию модели системы относительно всех «читателей».

Применим представленные аксиомы к описанному выше примеру. Поскольку абстракция в этом случае выполняется относительно предикатов, а в качестве символа замены будет использован некоторый символ, например. Таким образом, получим:  

Применение представленных выше аксиом позволило сократить общее число символов алфавита (предикатов) системы, однако число ее состояний и переходов осталось прежним. Правило позволяет сократить число состояний модели верифицируемой системы путем унификации однотипных элементов вычислительного пути. Применим данное правило к системе, полученной на предыдущем шаге, где  

Применение правил позволяет унифицировать однотипные переходы RLTL-модели. После применения данных правил модель примет вид 

Выполнив правило дизъюнкции, получим упрощенную модель системы «читатели-писатели» 

Таким образом, на конкретном примере за счет эффективного использования операций абстракции и унификации на RLTL-структурах исходную модель удалось сократить более чем в два раза. Исходная модель – 42 перехода, упрощенная модель – 20 переходов.

Приведем также пример упрощения модели светофора, описанной ранее в терминах RLTL. Пусть проверка этой системы будет выполняться относительно следующего условия, заданного в терминах LTL «Всегда в будущем будет загораться зеленый сигнал светофора». Тогда в качестве множества заменяемых символов можно взять  а в качестве символа замены используем просто символ, который будет означать stop. Таким образом, получим:  

После применения аксиом система уравнений примет следующий вид 

После применения аксиом система уравнений примет следующий вид 

Для сокращения числа состояний системы применим к ней правило , где , и получим.

И наконец, применив правила, получим сокращенную модель светофора.

В результате после выполнения операций абстракции и унификации модель светофора сократилась ровно в два раза.

В качестве более содержательного примера использования операций абстракции и унификации рассмотрим следующий случай. Пусть требуется выполнить верификацию множества драйверов и/или некоторых подпрограмм операционной системы, которые используют разделяемые ресурсы, например, оборудование или адреса в оперативной памяти, на предмет наличия в их совместной работе тупиков, гонок и взаимных блокировок. В таком случае последовательность шагов будет следующей.

1. Построить модель для каждого драйвера (подпрограммы) на базе RLTL.

2. Построить верифицируемые свойства на базе RLTL.

3. Для каждой модели выполнить операцию абстракции:  определить множество H как множество символов, соответствующих свойствам системы, отличным от свойств, задействованных при работе с разделяемыми ресурсами;  в качестве символа замены взять любой не использованный ранее символ;  выполнить абстракцию с помощью аксиом.

4. Для каждой модели выполнить операцию унификации с помощью аксиом.

5. Выполнить верификацию абстрагированных и унифицированных моделей систем.

За счет выполнения пункта 3 число свойств каждой модели сократится до числа тех свойств, которые сопоставляются операциям взаимодействия, плюс одно свойство, обозначаемое символом α и характеризующее все отличные от операций взаимодействия свойства. Выполнение пункта 4 позволит на порядок и более сократить размеры каждой модели за счет объединения однотипных блоков состояний, полученных после применения пункта 3. Таким образом, за счет того, что общая доля операций взаимодействия относительно всех операций драйвера крайне мала, в данном примере удается добиться многократного сокращения размеров верифицируемых моделей.

Заключение 

Авторами была рассмотрена RLTL-нотация в качестве новой структуры данных для задания моделей систем, что позволяет повысить эффективность и быстродействие процесса верификации за счет сокращения числа свойств систем, а также числа состояний и переходов. Было показано, что задание моделей систем с помощью RLTL не сложнее, чем на основе структур Крипке или на базе автоматов Бюхи. Модели, заданные на базе RLTL, как и модели на базе других структур данных, могут быть существенно упрощены за счет использования представленных в статье методов абстракции и унификации, что является важным аспектом для процесса верификации больших распределенных программных систем.

Таким образом, использование RLTL-нотации является важным и необходимым шагом, поскольку задание моделей верифицируемых систем и их требований сразу на базе единой унифицированной структуры позволяет сделать процесс верификации более гибким, быстрым и удобным.

