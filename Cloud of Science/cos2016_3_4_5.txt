Методы и средства профилирования и управления распределенными системами 



1. Введение 

Каждый разработанный программный модуль может включаться в состав разных программ, если выполнены условия его использования, декларированные в документации по этому модулю. Таким образом, программный модуль может рассматриваться и как средство борьбы со сложностью программ, и как средство борьбы с дублированием в программировании.  Они сокращают время разработки программ, облегчают внедрение и обеспечивают гибкость. Но модульное программирование так и не смогло полностью реализовать все свои концепции в полной мере [1]. Поэтому с развитием сетей и распределенных систем модули стали отдельными сетевыми приложениями, которые образовали сервис-ориентированные системы Software-as-a-Service (SaaS) и более сложные облачные системы. Сервисы предоставляют приложениям или другим сервисам свои услуги, решая ряд интеграционных проблем. Однако выросла сложность анализа таких систем, так как операции выполняются на различных вычислительных узлах и на каждую службу подается различная нагрузка. Поэтому сегодня является актуальным разработка методов и инструментальных средств для профилирования и управления распределенными системами. Все существующие сегодня системы для анализа распределенных систем строятся на основе анализа журналов работы (логов) всех служб, например ELK [2, 3] (Elasticsearch — для перенаправления потоков логов; Logstash — для поиска в логах; Kibana — для отображения пользователю результатов) или Dapper [4] от Google. Данные средства позволяют по предусмотренным разработчиками логам найти ошибки или «узкие» места, но не позволяют эффективно предпринять меры по их исправлению, т. е. выполнить управляющие воздействия на систему. Поэтому для профилирования и управления распределенными системами предпочтительным являются системы типа SCADA(Supervisory Control And Data Acquisition). Термин «SCADА-система» используется, когда речь идет об автоматизированных системах, т. е. системах контроля и управления, осуществляемого с участием человека, — диспетчера (оператора). В информационных системах производится огромное множество операций, за которыми оператор не в состоянии уследить, поэтому предпочтительным при профилировании и управлении показывать только ошибочные и трудозатраные, выходящие за норму, операции, что позволит найти узкие места в системе и переконфигурировать ее при необходимости. 

2. Методы профилирования распределенных систем 

Общепринятого метода и инструмента для профилирования распределенных систем сегодня нет, однако существует ряд предложенных методов в работах [5, 6]. Оба этих метода анализа и профилирования распределенных систем ориентированы на имитационное моделирование для проведения экспериментов и построение графовой модели системы. Проведя объединение и унификацию данных методов, можно выделить основные этапы профилирования распределенных систем: 

 формирование графового представления процесса решения функциональных задач как взаимосвязанной совокупности процессов обработки запросов; 

 построение и настройка имитационной модели процесса обработки запросов на конкретный вариант компьютерной сети и размещения распределенного информационного хранилища; 

 проведение эксперимента на имитационной модели для оценки времени выполнения запросов; 

 определение узких мест в системе, кардинально влияющих на производительность распределенной системы. 

В этих методах результаты профилирования зависят от имитационной модели, которая определяет нагрузку на систему с некой интенсивностью потока запросов. 

При профилировании распределенной системы с использованием расчетов показателей эффективности системы мониторинга необходимо учитывать: 

 множественность накопителей в системах массового обслуживания (СМО).Данный фактор приводит к рассмотрению СМО как системы с совокупной очередью заявок, исключающей получение характеристик отдельных очередей; 

 недетерминированное в общем случае время обслуживания единичной заявки; время, потраченное на обслуживание заявки зависит от общего объема пакета, в результате чего имеется взаимная зависимость среднего времени обслуживания заявки и количества заявок, ожидающих обслуживания; 

 корреляционные связи между временами поступления заявок, поступающих от различных элементарных источников, приводящие к отсутствию стационарности потока. 

При наличии рассчитаных показателей эффективности отдельных СМО можно провести расчет показателей эффективности стохастической сети массового обслуживания (СеМО), определяемой совокупностью характеристик [6]: 

1) множеством СМО образующих сеть; 

2) числом каналов в системах соответственно; 

3) матрицей траекторий движения заявок где — номер СМО, на которую переходит заявка, продвигающаяся по i-му пути на j-й фазе обслуживания при детерминированной процедуре маршрутизации, или матрицей вероятностей перехода заявок из одной СМО в другую где — вероятность того, что заявка, покидающая, поступает в 4) числом заявок, циркулирующих в замкнутой сети (Z); 5) интенсивностью источников заявок в разомкнутой сети где i — тип заявки; k — категория срочности; 

6) законами распределения времени и дисциплинами обслуживания заявок в системах. Системы и связи между ними определяют структуру сети. Интенсивность источников заявок интенсивность обслуживания длины очередей и режим работы приборов характеризуют нагрузку и производительность СеМО. 

Моделирование распределенной информационной системы на основе СеМО описано в работах [7, 8]. После построения имитационной модели для профилирования распределенной системы необходимо провести ряд экспериментов при различных архитектурах систем, в которых изменяется количество вычисляемых узлов, их расположение, потоки данных и прочие параметры. Автоматизировать построение данных систем и непосредственное проведение и сбор данных по результатам эксперимента позволят программные средства типа SCADA. 

3. Инструментальные средства профилирования и управления распределенными системами 

Инструментальные средства, автоматизирующие профилирование распределенных систем, реализованы в системе hmiSCADA (https://github.com/RSukharev/ hmiSCADA), написанной на языке C++ с использованием библиотеки Qt. В данном приложении использован принцип модульного построения. Система состоит из основного модуля, обеспечивающего полный набор базовых функций обработки и визуализации информации, а также дополнительных функциональных модулей-опций, реализующих функции сбора данных и необязательные в применении функции контроля и управления. Дополнительные модули сбора данных и управления включаются в исходный код профилируемой системы. 

Функционал основного модуля включает: 

 получение данных от внешних модулей; 

 обеспечение возможности управления процессом профилирования; 

 имитационное моделирование. 

Функционал дополнительных модулей включает: 

 сбор данных о времени начала и времени завершения тестируемого участка кода; 

 отправку данных о профилировании по сети на основной модуль системы; 

 выполнение команд, полученных от модуля визуализации и управления. 

Принципиальное отличие данной системы от других систем типа SCADA заключается в том, что для визуализации полученных данных оператору не требуется заранее строить мнемосхему того, что должно быть отображено. Мнемосхема формируется автоматически на основании полученных данных. Однако благодаря модульному принципу построения системы существует возможность в дальнейшем привести графический интерфейс пользователя к общепринятому стандарту. Также можно обеспечить совместимость со стандартами передачи данных в системах SCADA (OPC UA). Расширение функционала системы происходит по мере написания и подключения новых модулей. 

Модули подключаются динамически и имеют интерфейсы: 

1) request, предназначенный для отправки данных; 

2) processData, предназначенный для выполнения команд и обработки полученных данных. 

Работа системы построена на обмене сообщениями между модулями. Обмен сообщениями осуществляется при помощи структуры данных, состоящей из полей: senderID (идентификатор плагина-отправителя), receiverID (идентификатор плагина-получателя), command (команда для выполнения на стороне плагина-получателя) и value (пересылаемые данные). 

Архитектура системы позволяет построить схему, при которой сообщения могут проходить через цепочку модулей, каждый из которых выполняет свою работу по обработке данных и пересылает результат дальше, изменяя и расширяя функционал системы в целом. 

Компоненты системы отображены на рис. 1: 

Рисунок 1. Диаграмма компонентов системы hmiSCADA 

Основной компонент на диаграмме (HMI SCADA) состоит из элементов: 

 Controller (является диспетчером сообщений и обеспечивает обмен данными между модулями системы); 

 Visualiser (модуль визуализации, обеспечивает отображение полученных данных в виде мнемосхемы и предоставляет графический интерфейс пользователя для управления процессом профилирования); 

 PluginUDP (сетевой модуль, обеспечивает прием сообщений по сетевому протоколу UDP от модуля AgentUDP и перенаправление компоненту Controller, а также отправку по сети управляющих команд от Controller-a модулю AgentUDP); 

 Syslog (модуль анализа логов, используется для получения данных о профилировании на основании анализа логов системы); 

 Model (модуль, предназначенный для имитационного моделирования). Дополнительные модули системы представлены на диаграмме компонентами: 

 Agent (модуль сбора данных и управления профилируемой системой); 

 SysLog source (любой источник данных, совместимых с форматом SysLog). 

Сбор информации обеспечен включением в исходный код профилируемой системы класса Profiler и осуществляется посредством макросов: 

Profiler _profiler_(nodeinfo, moduleinfo, __FILE__); 

_profiler_.start( __FILE__, __LINE__, ##__VA_ARGS__); 

#define PROFILE_BEGIN(nodeinfo, moduleinfo) 

#define PROFILE_START(...) 

#define PROFILE_STOP() 

#define ON_EXIT(...) _profiler_.onExit(); 

Макросы вызывают функции класса Profiler со следующими параметрами: 

 _profiler_.stop(profileBlock, __FILE__, __LINE__); 

название файла с исходным кодом и номер строки профилируемого блока. 

QString::number(getTimeNS())); 

Пример использования: 

#include "Profiler/profiler.h" 

std::string appID = qPrintable(QString("mini") + 

#define PROFILE_ENABLE 

#define PROFILE_BEGINNER PROFILE_BEGIN(appID, " "); 

#define PROFILE_ENDER PROFILE_STOP(); 

void mini::on_pbSend_released() { 

PROFILE_BEGINNER; 

// начало профилирования 

PROFILE_START(Q_FUNC_INFO); 

sendMessage(); 

PROFILE_ENDER; 

} 

Между макросами PROFILE_BEGINNER и PROFILE_ENDER может располагаться произвольное количество строк кода, главным требованием является лишь общий контекст исполнения (внутри одной функции или внутри одного блока).// окончание профилирования 

Модуль Agent является сетевым и одновременно управляющим модулем профилировщика. 

AgentUDP отправляет по сети сообщение на адрес и порт основного модуля системы. Получателем в сообщении указан модуль Visualiser. PluginUDP отдает принятые по сети данные классу Controller, добавляя к ним свой идентификатор в виде параметра pluginID (идентификатор плагина-ретранслятора). Controller перенаправляет данные модулю, указанному в сообщении как получатель, т. е. Visualiser. В сообщении отправителем указан идентификатор модуля AgentUDP, поэтому при возникновении необходимости отправки ответа или управляющей команды модуль Visualiser сформирует сообщение с данным идентификатором в качестве получателя. Сообщение от  Visualiser-а поступит диспетчеру сообщений Controller и затем перенаправится на модуль-ретранслятор (PluginUDP), который перешлет его по сети модулю AgentUDP с соответствующим идентификатором. Результаты профилирования простого чата, отправляющего сообщения по UPD, показаны на рис. 2. 

Рисунок 2. Визуализация результатов профилирования двух экземпляров приложения чата 

Экземпляры профилируемых приложений на рис. 2, отмечены иконкой с изображением рабочей станции. Функциональные блоки отмечены серыми квадратами с названием профилируемой функции. Последовательность переходов между функциональными блоками отмечена стрелками. При наведении курсора на функциональный блок появляется всплывающее окно с информацией о времени выполнения. Активные функции и переходы между ними выделяются зеленым цветом. Меню управления экземпляром профилируемого приложения вызывается нажатием правой клавишей мыши на иконке. По умолчанию предусмотрены пункты вывода информации о приложении и завершение приложения. 

4. Заключение 

Рассмотрены методы и инструментальные средства типа SCADA для профилирования и управления распределенными системами. Данные системы позволят автоматизировать процесс профилирования систем, что упростит поиск узких мест и ошибок в системе [9]. Важным фактором в развитии и популяризации таких систем типа SCADA является возможность интегрирования их в уже эксплуатирующиеся распределенные системы, поэтому в прототипе hmiSCADA предлагается модульная архитектура. Благодаря данной архитектуре сторонние разработчики получают возможность разрабатывать свои модули hmiSCADA. Потраченные трудозатраты на разработку данных модулей должны с легкостью окупиться сэкономленным временем на профилирование и анализ системы.

