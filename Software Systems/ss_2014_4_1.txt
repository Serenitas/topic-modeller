
Под контролируемым выполнением [1, 2] понимается специально организованный процесс функционирования аппаратно-программной системы, цель которого выполнение системой своих задач несмотря на наличие ошибок, атак и отказов.
Основные положения концепции контролируемого выполнения: интеграция средств информационной безопасности, отладки и управления [3]; распространение контролируемого выполнения на все этапы жизненного цикла системы; целостность набора средств контролируемого выполнения, различающихся по степени воздействия на целевую систему, возможность взаимодействия между этими средствами.
Частными случаями контролируемого выполнения являются применение средств управления информационными системами, интерактивная отладка [4], мониторинг систем, их самоконтроль [5], воспроизведение предыдущих сеансов работы систем [6], моделирование, сбор и анализ количественных характеристик их функционирования [7], самолечение систем [8, 9].
В данной работе в контексте контролируемого выполнения авторами предложена методика самолечения POSIX-систем, основанная на использовании механизма трассировки.
Самолечение подразумевает способность системы находить, исследовать ошибки в работе и реагировать на них.
Компоненты или системы, обладающие самолечением, должны уметь исследовать системные ошибки и, учитывая наложенные извне ограничения, вносить подходящие исправления.
Для автоматического нахождения системных ошибок или возможных будущих ошибок необходимо знать ожидаемое поведение системы.
Автономные системы должны иметь знание о своем поведении и способность оценивать его корректность в данной ситуации.
Стандарт фиксирует минимальную функциональность средств трассировки, которые должна предоставлять POSIX-совместимая операционная система.
В стандарте POSIX-2001 под трассировкой понимаются порождение, накопление и анализ данных о событиях, имевших место при выполнении пользовательского приложения.
Сведения о действиях, производимых при выполнении приложения, фиксируются в виде объектов данных, называемых событиями трассировки .
События и данные, необходимые для их интерпретации, записываются в потоки трассировки.
Трассируемый процесс должен быть специальным образом организован: реализующая его программа должна содержать точки трассировки действия, способные генерировать события трассировки.
Для каждого трассируемого процесса должен быть открыт по крайней мере один поток трассировки.
Процесс, создавший поток трассировки, называется трассирующим .
Анализирующим называется процесс, извлекающий события трассировки из общего потока с целью получения информации о поведении трассируемого приложения.
События трассировки подразделяются на пользовательские и системные.
Системные события генерируются в ответ на действия приложения или ОС.
Стандартом предусмотрен механизм фильтрации, позволяющий отменять генерацию событий определенных типов, сокращая таким образом объем трассировочных данных.
Одно из главных требований к системе трассировки минимизация накладных расходов.
Исходя из этого, потоки трассировки, как правило, хранят в оперативной памяти.
Для получения стабильной копии потока с целью последующего анализа стандарт предусматривает его сохранение в журнале трассировки в долговременной памяти.
И для потоков, и для журналов трассировки правила обработки ситуации заполнения могут сводиться к записи новых событий поверх самых старых или к приостановке трассировки.
Для потоков возможен сброс в журнал с последующей очисткой, а для журналов потенциально неограниченное расширение.
Стандарт определяет два способа анализа трассы: в ходе сбора событий  и после сбора событий .
В первом случае анализирующий процесс читает данные из потока событий, во втором из журнала.
Оба способа представлены на рисунках 1 и 2 соответственно.
Программный интерфейс трассировки POSIX должен предоставлять следующие возможности: параллельная трассировка системных и пользовательских событий; трассировка события, относящегося к конкретному процессу, а также системных событий, не относящихся к какому-либо процессу; управление трассировкой некоторого процесса как потоками управления этого процесса, так и внешними процессами; управление трассировкой некоторого потока управления другими потоками управления данного процесса.
И он должен удовлетворять ряду требований: одновременно может осуществляться трассировка только одного процесса, при этом необходимо запретить трассировку сущностей, больших, чем процесс, например группы процессов; каждый вновь порождаемый поток трассируемого процесса по умолчанию тоже является трассируемым; независимо разрабатываемый код может подвергаться трассировке без дополнительных настроек и без конфликтов; для доступа к потоку событий должен использоваться стандартный интерфейс прикладного программирования; формат потока и журнала трассировки не определяется; должна быть возможность поддержки нескольких потоков трассировки в системе.
Всю необходимую дополнительную информацию можно получить из [2].
Отметим несколько слабых мест этого стандарта.
Во-первых, нет возможности отлаживать группы процессов, что уже является серьезным ограничением для применения POSIX-2001 при мониторинге состояния распределенных приложений.
Во-вторых, не отражен механизм группирования потоков управления внутри одного процесса .
В-третьих, не прописаны механизмы и интерфейсы для группировки событий .
Тем не менее при разработке средств мониторинга и самолечения целесообразно использовать интерфейс POSIX-2001 в качестве базового с последующим его расширением.
Система называется самостабилизирующейся, если из любой конфигурации она за конечное время приходит в безопасную конфигурацию, а из безопасной всегда переходит в безопасную.
Аппаратно-программная система будет самостабилизирующейся, если этим свойством обладают аппаратура, операционная система и программные приложения.
Далее предлагается методика реализации самостабилизирующейся программной системы, основанная на анализе потока событий специально выделенным управляющим потоком.
Итак, для реализации механизма самостабилизации  разработчик программной системы должен описать так называемые сигнатуры правильного поведения системы.
Это последовательности пользовательских и системных событий, выполнение которых говорит о корректной реализации системы.
Соответственно, система должна быть надлежащим образом настроена, то есть в критические участки кода разработчик должен добавить вызовы функции генерации пользовательских событий, а также включить протоколирование необходимых системных событий.
Кроме того, при разработке системы необходимо зарезервировать определенные ресурсы  для отдельного потока управления или процесса, который будет выполнять функции монитора здоровья целевой системы.
Монитор здоровья следит за соответствием возникающих событий сигнатурам правильного поведения системы и в случае обнаруженного расхождения производит действия по стабилизации системы.
В простейшем случае перезапуск нескольких  потоков управления или процессов.
Для примера рассмотрим POSIX-процесс, содержащий три потока.
Два из них это сервер и клиент, связанные по UDP-протоколу, третий контролирует происходящее в них через проверку событий, генерируемых этими потоками, и при необходимости перезапускает сервер и клиента.
Клиент и сервер обмениваются сообщениями, а при получении и отправке фиксируют это в протоколе трассировки.
Использование UDP-протокола обеспечивает необходимую скорость работы системы, но не дает гарантии успешной доставки всех сообщений.
Для реализации механизма самостабилизации в данной системе контролирующий поток проверяет приходящие в протокол события и при несоответствии сигнатуре корректного поведения системы осуществляет ее перезапуск.
Код сервера: Код клиента аналогичен и вначале отправляет сообщение, а потом пытается получить ответ от сервера.
Контролирующий поток создает потоки клиента и сервера, затем начинает обработку приходящих событий: В заключение отметим, что разработанная авторами концепция контролируемого выполнения направлена на то, чтобы обеспечить выполнение системой своей миссии несмотря на внутренние ошибки и внешние случайные или умышленные деструктивные воздействия.
Контролируемое выполнение включает в себя широкий спектр механизмов информационноуправляющего воздействия, среди которых ключевая роль отводится средствам самоконтроля аппаратуры и программ, а также средствам самолечения.
Базой для выполнения технологических требований к средствам контролируемого выполнения служат использование стандартов и архитектурных подходов, разработанных для средств управления, интеграция средств информационной безопасности, отладки и управления.
Конфигурация системы является безопасной, если система демонстрирует поведение, соответствующее предварительно сформулированным требованиям.
В данной работе в контексте контролируемого выполнения авторами был исследован механизм трассировки POSIX-систем и предложена методика самолечения  аппаратнопрограммных систем.
Controlled execution is a specially organized process of hardware and software system functioning.
This system is intended to perform its tasks despite errors, attacks and failures.
The basics of controlled concept execution are: integration of information security, debugging and management tools; distribution of controlled execution for all phases of system life cycle; integrity of the controlled execution tools, differing in an impact degree on the target system, the possibility of interactions between these tools.
Special cases of controlled execution are: information systems controlling; interactive debugging; system monitoring; system self-control; playback the previous sessions of the systems; modeling, collection and analysis of quantitative characteristics of systems; system selfhealing.
Taking in the context of controlled execution, the authors propose a POSIX-systems selfhealing technique based on the POSIX trace mechanism.
There is a brief review of a trace mechanism described in POSIX-2001.
The paper proposes a technique of software systems selfhealing based on this mechanism and integrated into controlled execution concept.
POSIX-2001 fixes the minimum functionality of tracing tools, which should be provided by a POSIX-compliant operating system.
POSIX-2001 standard refers tracing as collection, accumulation and analysis of data on the events that took place in the user application operation.
The work includes an example which can be useful in the practical application of selfhealing methods.
1.
The main concepts of the complex systems controlled execution paradigm.
[Information Technologies].
Additional issue, no.
2.
Debugging and monitoring of distributed heterogeneous systems.
[Information Security.
Software Programming Tools.
Databases].
3.
Jackson D.
A direct path to dependable software..
2009, vol.
52, pp.
7888.
4.
Scottsdale AZ, USA, Coriolis Group Books, 2001.
5.
Reflecting on self-adaptive software systems..
2009, pp.
3847.
6.
Andrzejak A.
Generic Self-Healing via Rejuvenation: Challenges, Status Quo and Solutions..
2010, pp.
239242.
7.
Survey of Frameworks, Architectures and Techniques in Autonomic Computing..
2009, pp.
220225.
8.
Formalizing a Methodology for Designand Runtime SelfHealing..
2010, pp.
106115.
9.
The DiPS+ Software Architecture for Self-healing Protocol Stacks..
2004, pp.
233242.
10.
The Open Group Base Specifications.
Iss.
